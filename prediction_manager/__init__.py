"""Management service for system predictions and experiments."""

import json
import uuid
import datetime
import logging
from typing import Any, Dict, Optional, Callable

from quantum_sim import QuantumContext

from sqlalchemy import select
from sqlalchemy.orm import Session

try:  # Prefer SystemState from db_models if available
    from db_models import SystemState, Base, engine
except Exception:  # pragma: no cover - fallback definition
    from sqlalchemy import Column, Integer, String
    from db_models import Base, engine

    class SystemState(Base):  # type: ignore
        """Fallback table storing arbitrary key-value pairs."""

        __tablename__ = "system_state"

        id = Column(Integer, primary_key=True)
        key = Column(String, unique=True, nullable=False)
        value = Column(String, nullable=False)

    Base.metadata.create_all(bind=engine)


class PredictionManager:
    """Service to persist and retrieve system predictions and experiment designs.

    This class centralizes lifecycle management for scientific hypotheses and
    validation experiments generated by the system. Predictions and experiments
    are serialized to JSON and stored in a simple key-value table (``SystemState``)
    so they can later be revisited, validated and analyzed.
    """

    def __init__(
        self,
        session_factory: Callable[[], Session],
        state_service: Optional[Any] = None,
    ) -> None:
        """Create a :class:`PredictionManager`.

        Parameters
        ----------
        session_factory:
            Callable returning a new :class:`~sqlalchemy.orm.Session` instance.
        state_service:
            Optional helper providing ``get_state``/``set_state`` if available.
        """

        self.session_factory = session_factory
        self.state_service = state_service

    # ------------------------------------------------------------------
    def _set_value(self, key: str, value: str) -> None:
        if self.state_service is not None:
            self.state_service.set_state(key, value)
            return
        session = self.session_factory()
        try:
            state = (
                session.execute(
                    select(SystemState).filter(SystemState.key == key)
                )
                .scalars()
                .first()
            )
            if state:
                state.value = value
            else:
                state = SystemState(key=key, value=value)
                session.add(state)
            session.commit()
        finally:
            session.close()

    def _get_value(self, key: str) -> Optional[str]:
        if self.state_service is not None:
            return self.state_service.get_state(key, None)
        session = self.session_factory()
        try:
            state = (
                session.execute(
                    select(SystemState).filter(SystemState.key == key)
                )
                .scalars()
                .first()
            )
            return state.value if state else None
        finally:
            session.close()

    # ------------------------------------------------------------------
    def store_prediction(self, prediction_data: Dict[str, Any]) -> str:
        """Persist a generated prediction and return its unique identifier."""

        prediction_id = uuid.uuid4().hex
        record = {
            "prediction_id": prediction_id,
            "created_at": datetime.datetime.utcnow().isoformat(),
            "status": prediction_data.get("status", "pending"),
            "data": prediction_data,
        }
        self._set_value(f"prediction:{prediction_id}", json.dumps(record))
        logging.debug("Stored prediction", extra={"prediction_id": prediction_id})
        return prediction_id

    def get_prediction(self, prediction_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve a previously stored prediction."""

        raw = self._get_value(f"prediction:{prediction_id}")
        return json.loads(raw) if raw else None

    def store_experiment_design(self, experiment_data: Dict[str, Any]) -> str:
        """Persist a validation experiment and return its identifier."""

        experiment_id = uuid.uuid4().hex
        record = {
            "experiment_id": experiment_id,
            "created_at": datetime.datetime.utcnow().isoformat(),
            "data": experiment_data,
        }
        self._set_value(f"experiment:{experiment_id}", json.dumps(record))
        logging.debug(
            "Stored experiment design", extra={"experiment_id": experiment_id}
        )
        return experiment_id

    def get_experiment_design(self, experiment_id: str) -> Optional[Dict[str, Any]]:
        """Return a stored experiment design by ID."""

        raw = self._get_value(f"experiment:{experiment_id}")
        return json.loads(raw) if raw else None

    def update_prediction_status(
        self,
        prediction_id: str,
        new_status: str,
        actual_outcome: Optional[Dict[str, Any]] = None,
    ) -> None:
        """Update ``prediction_id`` to ``new_status`` and record outcome data."""

        record = self.get_prediction(prediction_id)
        if not record:
            logging.warning(
                "Prediction not found", extra={"prediction_id": prediction_id}
            )
            return
        record["status"] = new_status
        if actual_outcome is not None:
            record["actual_outcome"] = actual_outcome
            record["updated_at"] = datetime.datetime.utcnow().isoformat()
        self._set_value(f"prediction:{prediction_id}", json.dumps(record))
        logging.debug(
            "Updated prediction status",
            extra={"prediction_id": prediction_id, "status": new_status},
        )

    def schedule_annual_audit_proposal(
        self, *, current_time: Optional[datetime.datetime] = None
    ) -> Optional[str]:
        """Create an audit proposal once per year using ``quantum_sim``.

        Parameters
        ----------
        current_time:
            Optional timestamp used for scheduling logic. Defaults to now.

        Returns
        -------
        Optional[str]
            Identifier of the created proposal or ``None`` if not scheduled.
        """

        now = current_time or datetime.datetime.utcnow()

        last_run_raw = self._get_value("audit_scheduler_last_run")
        if last_run_raw:
            try:
                last_run = datetime.datetime.fromisoformat(last_run_raw)
                if (now - last_run).days < 365:
                    return None
            except ValueError:
                pass

        qc = QuantumContext()
        metric = qc.quantum_prediction_engine(["audit"]).get(
            "overall_quantum_coherence", 0.0
        )

        proposal_id = f"audit_{now.year}_{uuid.uuid4().hex}"
        payload = {
            "timestamp": now.isoformat(),
            "coherence": metric,
        }
        self._set_value(f"audit_proposal:{proposal_id}", json.dumps(payload))
        self._set_value("audit_scheduler_last_run", now.isoformat())
        return proposal_id

